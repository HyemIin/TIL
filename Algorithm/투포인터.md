# 투포인터 알고리-듬
![image](https://github.com/HyemIin/TIL/assets/114489245/e27f92f5-9c3f-49a7-a266-00bb009fffb2)
- (정의) 리스트(1차원 배열)에 순차적으로 접근해야 할 때 두 개의 점의 위치를 기록하면서 처리하는 알고리즘
- (why?) 길이가 몹시 긴 리스트를 완전탐색하기엔 시간초과가 날 것 같을 때 활용. 문제에서 보통 "2개"의 체크포인트를 지칭하는 워딩이 등장하면 투포인터를 의심할 것.
- (why not?) 시간초과,,, 완전탐색으로 모든 요소를 다 비교한다면 O(N^2)의 어마무시한 시간 복잡도를 접할 수 있을 것

- 기본적으론 순차적 흐름으로 진행하나, 간혹 start는 순차적, end는 역순으로 진행하는 문제도 있다.

<details>
<summary>기초적인 코드 흐름은 아래와 같다.(진짜 흐름만)</summary>
start,end,count,result = 0,0,0,0 <br>
while (조건): <br>
  if result < 특정값: <br>
  elif result > 특정값: <br>
  else: <br>
    count += 1 <br>
  </details>
  
- 그때 그때 결과값이 원하는 값과 일치하는지 비교해나가면서 원하는 값보다 크면 start를 한칸 밀고, 원하는 값보다 작으면 end를 한칸 땡기는 식으로 "완급조절"을 하는 것이 핵심이다.<br>
그러므로, 2중 for문과 같은 loop를 통해 모든 결과값을 일일이 대조하는 완전탐색 방법을 쓰는 것보다 시간 복잡도는 훨씬 줄어든다.
- 시간복잡도 : O(N) <br> 매 루프마다 항상 두 포인터 중 하나는 1씩 증가하고 각 포인터가 n번 누적 증가해야 알고리즘이 끝나기 때문에 시간복잡도는 O(N)이다.<br>
(정확히는 2*O(N)이지만,,여기선 그정돈 신경 안씀)


